import{r as t}from"./vendor-react-BqCNLigP.js";const a="downloads",e={QUEUED:"queued",DOWNLOADING:"downloading",PAUSED:"paused",COMPLETED:"completed",FAILED:"failed",CANCELLED:"cancelled"},s=()=>{const[s,o]=t.useState([]),[r,n]=t.useState(!1),[c,i]=t.useState({used:0,available:0,percentage:0}),d=t.useCallback(()=>new Promise((t,e)=>{const s=indexedDB.open("nikzflix_downloads",1);s.onerror=()=>e(s.error),s.onsuccess=()=>t(s.result),s.onupgradeneeded=t=>{const e=t.target.result;if(!e.objectStoreNames.contains(a)){const t=e.createObjectStore(a,{keyPath:"id"});t.createIndex("status","status",{unique:!1}),t.createIndex("addedAt","addedAt",{unique:!1})}}}),[]),l=t.useCallback(async()=>{try{const t=(await d()).transaction(a,"readonly"),e=t.objectStore(a).getAll();e.onsuccess=()=>{o(e.result||[])}}catch(t){}},[d]),u=async()=>{if(navigator.storage&&navigator.storage.estimate)try{const t=await navigator.storage.estimate(),a=t.usage||0,e=t.quota||0,s=e>0?a/e*100:0;i({used:Math.round(a/1048576),available:Math.round(e/1048576),percentage:Math.round(s)})}catch(t){}};t.useEffect(()=>{(async()=>{const t="serviceWorker"in navigator&&"indexedDB"in window&&"storage"in navigator;n(t),t&&(await l(),await u())})()},[l]);const w=async(t,a=null)=>{try{if(!(a||s.find(a=>a.id===t)))return;await D(t,e.DOWNLOADING),y(t)}catch(o){await D(t,e.FAILED,{error:o.message})}},y=t=>{let s=0;const o=setInterval(async()=>{try{const r=(await d()).transaction(a,"readonly"),n=r.objectStore(a).get(t);n.onsuccess=async()=>{const a=n.result;a&&a.status!==e.CANCELLED&&a.status!==e.PAUSED?(s+=10*Math.random()+5,s>=100?(s=100,clearInterval(o),await g(t,{status:e.COMPLETED,progress:100,completedAt:(new Date).toISOString()})):await g(t,{progress:Math.min(s,100),status:e.DOWNLOADING})):clearInterval(o)},n.onerror=()=>{clearInterval(o)}}catch(r){clearInterval(o)}},800)},D=async(t,a,e={})=>{await g(t,{status:a,...e})},g=async(t,e)=>{try{const s=await d(),o=s.transaction(a,"readwrite").objectStore(a),r=o.get(t);r.onsuccess=async()=>{const t=r.result;if(t){const a={...t,...e};await o.put(a),await l()}}}catch(s){}},p=t.useCallback(t=>s.some(a=>a.itemId.toString()===t.toString()&&a.status===e.COMPLETED),[s]),S=t.useCallback(t=>s.find(a=>a.itemId.toString()===t.toString()&&a.status===e.COMPLETED),[s]),E=t.useCallback(t=>s.filter(a=>a.status===t),[s]);return{isSupported:r,downloads:s,storageInfo:c,addDownload:async(t,s="720p")=>{try{const o={id:`${t.id}_${s}_${Date.now()}`,itemId:t.id,title:t.title||t.name,poster:t.poster_path,backdrop:t.backdrop_path,overview:t.overview,mediaType:t.media_type||(t.first_air_date?"tv":"movie"),quality:s,status:e.QUEUED,progress:0,addedAt:(new Date).toISOString(),completedAt:null,size:0,error:null},r=await d(),n=r.transaction(a,"readwrite").objectStore(a);return await n.add(o),await l(),await u(),w(o.id,o),o}catch(o){throw o}},startDownload:w,pauseDownload:async t=>{try{await D(t,e.PAUSED)}catch(a){}},resumeDownload:async t=>{try{const s=(await d()).transaction(a,"readonly"),o=s.objectStore(a).get(t);o.onsuccess=async()=>{const a=o.result;a&&(await D(t,e.DOWNLOADING),w(t,a))}}catch(s){}},cancelDownload:async t=>{try{await D(t,e.CANCELLED),await l()}catch(a){}},deleteDownload:async t=>{try{const e=await d(),s=e.transaction(a,"readwrite").objectStore(a);await s.delete(t),await l(),await u()}catch(e){}},clearCompleted:async()=>{try{const t=await d(),s=t.transaction(a,"readwrite").objectStore(a),o=s.index("status");o.openCursor(e.COMPLETED).onsuccess=t=>{const a=t.target.result;a?(s.delete(a.primaryKey),a.continue()):(l(),u())}}catch(t){}},clearAll:async()=>{try{const t=await d(),e=t.transaction(a,"readwrite").objectStore(a);await e.clear(),await l(),await u()}catch(t){}},isDownloaded:p,getDownloadByItemId:S,getDownloadsByStatus:E,updateStorageInfo:u}};export{e as D,s as u};
